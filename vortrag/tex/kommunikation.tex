\section{Kommunikation und Sicherheit}
\label{sec:kommunikation}

Wie in Kapitel \ref{sec:ms-arch-sec} beschrieben, besteht ein Microservice-basiertes System aus einer Menge von mindestens einem physikalischen Host und beliebig vielen Microservices. Um überhaupt von einem System sprechen zu können, müssen die einzelnen Komponenten noch vernetzt werden. Wir benutzen im Folgenden den Ausdurck \textit{Service-to-Service-Kommunikation} -- StS-Kommunikation. Services kommunizieren miteinander, tauschen Nachrichten aus, fordern Dinge an die von einem anderen Service berechnet werden müssen etc \cite{newman2015}. Diese Kommunikation kann angegriffen werden, insbesondere wenn die Kommunikation über unsichere Kanäle stattfindet wie etwa das World-Wide-Web.

Im Folgenden wollen wir verschiedene Möglichkeiten von \stscom erläutern, Vor- und Nachteile diskutieren und auf Sicherheitsaspekte eingehen.

\subsection{Kommunikationswege}

Kommunikation zwischen Microservices findet fast immer event basiert statt. Die Eventverarbeitung kann synchron oder asynchron stattfinden \cite{newman2015}. Dadurch, dass Microservices immer genau eine logische Aufgabe erfüllen, werden sie meist von extern dazu angestoßen etwas zu verarbeiten (\textit{receive-event}). Wenn ein Microservice etwas verarbeitet hat, dann gibt er entweder das Ergebnis zurück oder verschickt eine Nachricht, dass nun ein Ergebnis vorliegt (\textit{send-event}). „Applications built from microservices aim to be as decoupled and as cohesive as possible [...] receiving a request, applying logic as appropriate and producing a response“ \cite{Fowler+14}. Wir werden dies an den zwei populärsten Verfahren zur \stscom\ erläutern: \textit{Message Queues} und \textit{REST} \cite{Fowler+14,newman2015}. Dabei werden Aufgabengebiete hearausgestellt, für die die jeweilge Kommunikationsart im Mircoservice Kontext am geeignetsten erscheinen.

\subsubsection{REST}

REST ist die Kurzschreibweise für „Representational State Transfer“, eine zustandslose, protokollbasierte Frage-Antwort-Kommunikationsform. Darüber hinaus beschreibt REST umgangssprachlich auch einen Architektur-Ansatz, um verteilte Anwendungen zu entwerfen \cite{webber2010}. Für detaillierte Informationen zum Thema REST empfehlen wir \textit{REST in Practice, O'Reilly}.

Im Microservice Kontext lässt sich REST hervorragend für \stscom\ verwenden \cite{Fowler+14}. Dabei wird in der Regel das HTTP Protokoll verwendet. Um über REST Schnittstellen kommunizieren zu können, müssen die jeweiligen Microservices in der Lage sein, einander anzusprechen. Es müssen also die IP-Adressen der einzelnen Komponenten bekannt sein, etwa durch Service-Discovery (siehe \ref{subsec:arch-requirements}). 

HTTP Kommunikation kann belauscht und unterbrochen werden, außerdem ist sie anfällig für Man-in-the-Middle Angriffe und vergleichbare Szenarien. Um ein wenig mehr Sicherheit zu schaffen, kann zur \stscom\ auch HTTP/s verwendet werden können. HTTP/s für sich allein bringt nach \cite{newman2015} nur einen geringen Vorteil. Zwar ist dann der Traffic verschlüsselt, aber in der Regel sind die APIs der Services frei ansprechbar. Daher wird zusätlich empfohlen, dass die einzelnen Microservices sich bei anderen authentizieren. Ein solider und einfacher Ansatz wäre etwa Basic-Auth über HTTP/s. Die Übetragung von Username und Passwort erfolgt verschlüsselt; es kann sichergestellt werden, dass nur berechtigte Services anderen Services Nachrichten schicken dürfen. Außerdem kann zu späteren Zeitpunkten anhand von Logs und Usernamen nachgewiesen werden, wann und zwischen welchen Services eine Kommunikation stattgefunden hat. Im folgenden Kapitel werden wir Verfahren zum Schutz und zur Authentizierung detaillierter behandeln. 

REST eignet sich für Microservice-basierte Systeme insbesondere, wenn der Bedarf nach synchroner Kommunikation gegeben ist. Nachdem ein Service mit einem Request angesprochen wurde, erwartet der Anfragende eine entsprechende Antwort. Als Übertragungsformat kommen meist leichtgewichtige und ausdrucksstarke Text-Formate zum Einsatz wie JSON und XML. Von Vorteil ist auch, dass es eine breite Unterstüzung in Form von Frameworks und HTTP Clients gibt, sodass meist nur minimaler Overhead entsteht, um einer Software-Komponente zu ermöglichen via REST zu kommunizieren.

Da die Kommunikation via REST synchron ist, ergeben sich Probleme wenn ein Service neu gestartet, gelöscht oder ersetzt wird. Bestehende Verbindungen werden unterbrochen und erwartete Anworten bleiben aus. Der Anfrangende Service muss selbst eine Fehlerbehandlung implementieren, wenn benötigte Antworten nicht kommen. 

\subsubsection{Message Queues}

Das Konzept einer Queue werden wir nicht näher erläutern. Einen guten Überblick liefert \cite{hohpe2003}. Kommunikation über Queues ist immer asynchron. Wenn etwas in einer Queue abgelegt wurde, verweilt es dort bis es wieder herausgenommen wird. Sender und Emfänger müssen einander nicht kennen. Es kann beliebig viele Sender und beliebig viele Empfänger geben. Queues lassen sich auch als Puffer verwenden. 

Im Microservice Kontext lassen sich Queues insbesondere gut dafür verwenden, asynchrone, horizontal skalierbare Worker-Chains zu realisieren \cite{newman2015}. Dabei wird eine große logische Verarbeitungsaufgabe in viele kleine Einzelschritte zerlegt. Ein Microservice bildet die Arbeitsoperation eines Teilschrittes ab. Dabei lauscht ein Microservice auf einer Queue, sobald etwas verfügbar ist wird es abgearbeitet und das Ergebnis auf eine andere Queue geschrieben. Wenn ein Verarbeitungsschritt absehbar mehr Zeit kostet als andere, so können einfach weitere Microservices gestartet werden, die an der gleichen Queue lauschen, sodass dort mehr Durchsatz geschaffen wird. 

Ein gewaltiger Vorteil von Queueing ist, dass diese Kommunikationsarchitektur das Problem der Service-Discovery etwas abschwächt. Worker-Services müssen nur die entsprechende Queue kennen, auf der sie lauschen bzw. schreiben. Services müssen sich gegenseitig nicht kennen, um zu kommunizieren. So wird das Skalieren, Stoppen oder Ersetzen von Services völlig transparent für das Gesamtsystem.

Probelematisch ist allerdings hier die Integrität von Nachrichten. Services sollten sich auf ein dediziertes Format einigen und jede angenommene Nachricht zunächst validieren und verifizieren. Da Sender und Empfänger sich nicht kennen, ist es schwierig den Absender eindeutig festzustellen. Allerdings kann durch ein geteiltes Nachrichtenformat, etwa durch ein JSON-Schema oder Ähnliches sichergestellt werden, dass eingehende Nachrichten überhaupt verarbeitet werden können.

Queues implementiert man in der Regel nicht selbst, sondern greift auf bestehende Lösungen zurück. Es gibt zwei sehr aktuelle Message Queues, die für Microservice-Systeme verwendet werden. Das ist zum einen \textit{RabbitMQ}\footnote{\url{https://www.rabbitmq.com/}}, zum anderen \textit{ZeroMQ}\footnote{\url{http://zeromq.org/}}. Beim Einsatz jedweder Lösung sollte man stets darauf achten, dass Nachrichten vor Modifikation durch unbefugte geschützt sind. So könnte etwa bei jeder Nachricht in der Queue noch ein entsprechender Hash mitgeschickt werden, der zusätzlich zum Nachrichtenformat zur Validierung der Nachricht verwendet wird.

Im Folgenden werden wir Schutzziele definieren und auf Microservice-Systeme sowie auf Kommunikation übertragen. Es werden einige konkrete Verfahren und Bibliotheken vorgestellt, mit denen sich diese Schutzziele umsetzen lassen. 
